#!/usr/bin/env python

import rospy, cv2, cv_bridge
import math
import numpy as np
from sensor_msgs.msg import Image
from std_msgs.msg import Int32
from preprocess_img import TriangleMask
from edge_detection import EdgeDetection

'''
This function is not used in the main. The original intention for this class was to be able to
keep the robot within the lane lines while still avoiding obstacles in its path.
''' 

class Lines:

    def __init__(self):

        self.img_sub = rospy.Subscriber('/canny_mask', Image, self.img_cb)
        self.og_img_sub = rospy.Subscriber('/camera/rgb/image_raw', Image, self.og_img_cb)
        self.img_pub = rospy.Publisher('/line_overlay', Image, queue_size=1)
        self.bridge = cv_bridge.CvBridge()
        self.lines = None

    def img_cb(self, img_msg):

        img = self.bridge.imgmsg_to_cv2(img_msg)


        # Defines lines in image with Hough line transform
        self.lines = cv2.HoughLines(img,  1, math.pi / 180, 60, 0, 0, min_theta=2.5*math.pi/4, max_theta=5.5*math.pi/4)

    def og_img_cb(self, img_msg):
        img = self.bridge.imgmsg_to_cv2(img_msg, 'bgr8')
        try:
            thetalist = []

            # For loop iterates through lines generated by Hough transform
            for line in self.lines:
                rho = line[0][0]
                theta = line[0][1]
                thetalist.append(rho)
                a = math.cos(theta)
                b = math.sin(theta)
                x0 = a * rho
                y0 = b * rho

                # defines the start and endpoint of each line
                x1 = int(x0 + 1000*(-b))
                y1 = int(y0 + 1000*(a))
                x2 = int(x0 - 1000*(-b))
                y2 = int(y0 - 1000*(a))
                #draws line on image
                img = cv2.line(img, (x1, y1), (x2, y2), (255, 255, 0), 3)
            #publishes the original raw image with the lines drawn on it
            self.img_pub.publish(self.bridge.cv2_to_imgmsg(img))
        except TypeError as e:
            avgangle = 180
            pass
        # prints the average angle of the lines
        print(avgtheta)

if __name__ == "__main__":
    rospy.init_node('centroid_finder')
    mask_publisher = TriangleMask()
    edge_detector = EdgeDetection()
    line_finder = Lines()
    rospy.spin()
